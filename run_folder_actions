#! /usr/bin/env bash

#############
#### Usage:
####   ${ME} [-f FAILURE_ACTION] [-s SUCCES_ACTION] [-e AFTER_EACH_ACTION] -a ACTION...
####   ${ME} [-f FAILURE_ACTION] [-s SUCCES_ACTION] [-e AFTER_EACH_ACTION] -d DEFAULT_ACTION
####   ${ME} [-f FAILURE_ACTION] [-s SUCCES_ACTION] [-e AFTER_EACH_ACTION] -d DEFAULT_ACTION -a ACTION...
### 
###  Processes the contents of the current/working directory using the specified
###  actions.  Actions are specified by matching a glob pattern to an executable (
###  we'll refer to these as handlers).
###
###  e.g.
###   *.gif=/path/to/gif/handler
###
###  Since invocation requires passing a glob=path string, you'll need to pay close
###  attention to quoting or escaping the ACTION and DEFAULT_ACTION parameters.
###
###  When a glob pattern associated for a handler matches a file in the current 
###  directory, the handler will be invoked with the full path to the matching file
###  as the only parameter.
###
###  e.g.
###   /path/to/gif/handler /current/directory/pants.gif
###
###  The steps for invocation of a handler are has follows.
###
###  - for each action glob, find any matching files in the current directory
###  - lock the matched file by creating a 'lock directory' named the same as the
###    file with an extension of .lock.
###  -- if the lock fails to be aquired, a log message will be printed and processing
###     will continue with the next match
###  - log a start indicator to standard out, indicating the handler invoked and
###    the start time of the execution of the handler
###  - with the lock aquired, invoke the handler as described above redirecting the 
###    standard output and error streams from the handler to the stdout of ${ME}
###  - log an end indicator, indicating the handler invoked and the completion time
###  - if the handler exited with a non-zero exit code invoke FAILURE_ACTION
###  - if the handler exited with an exit code of zero invoke SUCCESS_ACTION
###  - if there is an AFTER_EACH_ACTION, invoke it
###
#############

##############################################################################
# <Utils>
usage() {
  echo
  egrep '^#{4} ' ${0} | sed -r -e 's[^#{4}[ [g' | sed -e "s[\${ME}[${0}[g"
  echo
  exit 1
}
show_help() {
  echo
  egrep '^#{3}$|^#{3} |^#{4}$|^#{4} ' ${0} | sed -r -e 's[^#{3,4}[[' | sed -e "s[\${ME}[${0}[g" | less
  echo
  exit 2
}
write_log(){ 
  LEVEL=${1}
  shift
  if [ -n "${LEVEL}" ]; then
    echo "`date +"%x %X"` [${LEVEL}] $@";
  else
    echo "`date +"%x %X"` $@";
  fi
}
export -f write_log

hash_file(){
  THIS_FILE=$1
  openssl md5 ${THIS_FILE} | sed -e 's[MD5.* [[g'
}
export -f hash_file

log_divider() { write_log "******************************************"; }
export -f log_divider

error() { write_log ${FUNCNAME^^} $@; }
export -f error

warn()  { write_log ${FUNCNAME^^} $@; }
export -f warn

info()  { write_log ${FUNCNAME^^} $@; }
export -f info

debug() { [ -n "${DEBUG}" ] && write_log ${FUNCNAME^^} $@; }
export -f debug

die() { echo $1 ; exit ${2-1} ;}
export -f die

abs_path() {
  (cd "${1%/*}" &>/dev/null && printf "%s/%s" "$(pwd)" "${1##*/}")
}
export -f abs_path

function abspath {
    if [[ -d "$1" ]]; then
        pushd "$1" >/dev/null
        pwd
        popd >/dev/null
    elif [[ -e $1 ]]; then
        pushd "$(dirname "$1")" >/dev/null
        echo "$(pwd)/$(basename "$1")"
        popd >/dev/null
    else
        # the path we're given doesn't exist
        return 127
    fi
}
export -f abspath

# </Utils>
##############################################################################

DEFAULT_ACTION=
declare -a ACTION_LIST
ACTION_INDEX=0
DO_NOT_RUN=
while getopts "ha:d:t" o; do
    case "${o}" in
        a)
            ACTION=${OPTARG}
            ACTION_INDEX=$((( $ACTION_INDEX + 1 )))
            ACTION_LIST[${ACTION_INDEX}]=$ACTION
            ;;
        d)
            [ -z "${DEFAULT_ACTION}" ] || ( echo "only one default action allowed" && exit 1 )
            DEFAULT_ACTION=${OPTARG}
            ;;
        h)
            show_help
            ;;
        t)
            DO_NOT_RUN=true
            ;;
        *)
            usage
            ;;
    esac
done
# if we have no default action, and there's no other actions specified
# we should tell our caller how we're used, since there's nothing to do
[ -z "${DEFAULT_ACTION}" -a "${#ACTION_LIST[*]}" -eq 0 ] && usage
for index in $(seq ${#ACTION_LIST[*]})
do
  # split our action on = so we get a glob, exe pair
  IFS='=' read -ra ACTION_PARTS <<< "${ACTION_LIST[$index]}"
  # check our current directory for 'glob matches'
  for file in "./${ACTION_PARTS[0]}"
  do
    if FULL_PATH=$(abspath $file); then
      if [ -r "$FULL_PATH" -o -d "$FULL_PATH" ]; then
        if [ -z "${DO_NOT_RUN}" ]; then
          info "Running ${ACTION_PARTS[1]} for $FULL_PATH"
          (
            ${ACTION_PARTS[1]} "${FULL_PATH}"
          )
        fi
      fi
    fi
  done
done
